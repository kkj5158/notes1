#oop

# 구현체는 인터페이스의 모든 기능을 사용해야한다.
### 그러기 위해서, 인터페이스를 최대한 잘게 쪼개야(분리) 해야함! 
#### 그리고 인터페이스와 1대1 대응을 이뤄야 한다. 

### 인터페이스 분리 원칙을 위반한다면, 

![[Pasted image 20240125091934.png]]


위의 그림에서는 `User1`, `User2`, `User3` 객체들이 OPS를 상속 받고 있습니다. 이 때 `User1`은 오직 op1 메서드만을, `User2`는 오직 op2 메서드만을, `User3`는 오직 op3 메서드만을 사용한다고 가정해보겠습니다.

이 상황에서 `User1`은 OPS 전체를 상속 받았기 때문에 op1, op2, op3 메서드를 모두 사용할 수 있지만, 정작 op1 메서드만을 필요로 합니다. `User1`은 op2를 사용하지 않음에도 불구하고 만약 op2 메서드에 변경이 일어나면, 함께 변경되어 재컴파일 & 재배포 과정을 거쳐야하는 문제가 생깁니다. 

##### 이건 모두 , 인터페이스를 분리하지 않았기 때문 !! 

### 인터페이스 분리 원칙을 준수한다면 , 

이런 경우, 설계에 인터페이스 분리 원칙을 적용해 문제상황을 해결할 수 있습니다.

![](https://velog.velcdn.com/images/harinnnnn/post/f4c05e79-6559-4d32-a41e-57a0785be03f/image.png)

**OPS는 OPS를 상속 받는 U1Ops, U2Ops, U3Ops로 잘게 분리 되었습니다.** 이렇게 분리되면, 각각의 객체들은 오직 자신이 필요한 메서드만을 사용할 수 있는 구조가 됩니다.

이 경우에는 op2 메서드의 변경이 일어나더라도 `User1` 객체에는 전혀 영향이 가지 않습니다. ISP를 준수한 바람직한 설계 구조라고 볼 수 있습니다.