#oop
#### 참고자료 

[ 완벽하게 이해하는 SRP (단일 책임 원칙)](https://inpa.tistory.com/entry/OOP-%F0%9F%92%A0-%EC%95%84%EC%A3%BC-%EC%89%BD%EA%B2%8C-%EC%9D%B4%ED%95%B4%ED%95%98%EB%8A%94-SRP-%EB%8B%A8%EC%9D%BC-%EC%B1%85%EC%9E%84-%EC%9B%90%EC%B9%99)
만들면서 배우는 클린 아키텍쳐 
단일 책임 원칙은 보통 다음의 정의로 많이 알려져 있다. 
# 하나의 책임, 하나의 이유 
## 단일 책임 원칙이 아니라, 단일 변경 이유  원칙이다. 

단일 책임 원칙을 개념적으로만 바라본다면 . 다음과 같은 정의가 나올것이다. 
### 하나의 컴포넌트는 오로지 한 가지 일만 해야 하고, 그것을 올바르게 수행해야 한다. 

실용적인 관점을 더해서 조금만 더 디테일하게 해당 정의를 수정해보자. 해당 정의를 개발자의 입장에서, 실용적인 관점으로 변경한다면 다음으로 정의 내릴 수 있다 .

### 컴포넌트를 변경하는 이유는 오직 하나뿐이어야 한다. 

당연히 컴포넌트를 변경할 이유가 오로지 한 가지라면 컴포넌트는 딱 한가지 일만 하게 된다. 하지만 이보다 더 중요한 것은 ==변경할 이유가 오로지 한가지라는 사실이다.== 

#### 단일 책임 원칙을 준수하는 가장 큰 베네핏은 기능 변경이 일어났을때의 파급효과를 최소화 시키는데 있습니다. 

한 객체에 책임이 많아질수록 클래스 내부에서 서로 다른 역할을 수행하는 코드끼리 강하게 결합될 가능성이 높아지게 되어 시스템이 복잡해질 수 있습니다. 그래서  그 객체가 하는 기능에 변경사항이 생기면 이 기능을 사용하는 부분의 코드를 모두 다시 테스트를 해야 할 수 도 있습니다. 


# Example 
```java
class Employee {
    String name;
    String positon;

    Employee(String name, String position) {
        this.name = name;
        this.positon = position;
    }

	// * 초과 근무 시간을 계산하는 메서드 (두 팀에서 공유하여 사용)
    void calculateExtraHour() {
        // ...
    }

    // * 급여를 계산하는 메서드 (회계팀에서 사용)
    void calculatePay() {
        // ...
        this.calculateExtraHour();
        // ...
    }

    // * 근무시간을 계산하는 메서드 (인사팀에서 사용)
    void reportHours() {
        // ...
        this.calculateExtraHour();
        // ...
    }

    // * 변경된 정보를 DB에 저장하는 메서드 (기술팀에서 사용)
    void saveDababase() {
        // ...
    }
}
```

다음의 클래스를 생각해보자. 해당 클래스는 직원정보를 담당하는 클래스로 다음과 같이 4개의 메소드를 가지고 있다. 

- calculatePay() : 회계팀에서 급여를 계산하는 메서드
- reportHours() : 인사팀에서 근무시간을 계산하는 메서드 
- saveDababase() : 기술팀에서 변경된 정보를 DB에 저장하는 메서드
- calculateExtraHour() : 초과 근무 시간을 계산하는 메서드 (회계팀과 인사팀에서 공유하여 사용)

각 메서드들은 각 팀에서 필요할 때마다 호출해 사용한다고 가정하자. 

아래 예시 코드에서는 calculatePay 메서드와 reportHours 메서드에서 초과 근무 시간을 계산하기 위해 calculateExtraHour() 메서드를 공유하여서 사용하고 있다. 

# 아키텍쳐에서의 의미

#### 완전히 독립되어서. 어디에나 조립이 가능한 모듈이라는 의미입니다. 

만약 컴포넌트를 변경할 이유가 한 가지라면 우리가 어떤 다른 이유로 소프트웨어를 변경하더라도 이 컴포넌트에 대해서는 전혀 신경 쓸 필요가 없다. 소프트웨어가 변경되더라도 여전히 우리가 기대한 대로 동작할 것이기 때문이다. 

하지만 개발자가 익히 알듯이 안타깝게도 변경할 이유라는 것은 컴포넌트 간의 의존성을 통해 너무도 쉽게 전파된다. 

