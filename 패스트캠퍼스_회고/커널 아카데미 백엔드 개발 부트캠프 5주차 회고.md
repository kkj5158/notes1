# 회고 
## 자바/OOP 모듈이 끝났다. 

자바/OOP 모듈이 끝났다. 자바중에서 어려웠던 장들을 따로 정리해나가야할것 같은 생각이 들어서 미리 기록해둔다. 
남궁성 강사님께서 말씀하신 대로 가장 중요한건 역시 기본기였다. 자바를 어느정도는 안다고 생각했지만. 이렇게 까지 딥다이브 해본적이 없어서 툭툭 튀어나오는 깊이 있는 개념에 많이 당황했다. 

<img src=KakaoTalk_20250501_132032337_02.jpg width="600" height="400">

언제 다 배울까 걱정했지만,, 그래도 일단 한바퀴 돌았다.. ! 
### 지금까지 배운 내용들 복습하기

복습하는 가장 좋은 방법은 연습문제를 풀고 복습하고 또 푸는 것 밖에 길이 없었다. 자바의 정석 연습문제를 풀고 또 풀다보면 개념이 자연스럽게 체득되어서 깊은 공부가 가능했다.

<img src=KakaoTalk_20250501_132032337.jpg width="600" height="400">

## 점점 업그레이드 되는 이력서 

강사님께 이력서를 피드백을 5번정도 받았다. 아무런 조건없이 언제나 친절하게 피드백 해주신다는 점이 너무나도 감사했다. 강사님의 이력서 강의도 참고해서 이력서를 점차 피드백 해나갔다. 

[강사님 이력서 강의](https://www.youtube.com/watch?v=ilkv-dtnnus&t=5369s)
### 이력서의 핵심은 짧은 분량내에 임팩트 있는 정보만을 담아가는 것 

강사님에게 피드백 받을때마다 듣는 내용은. "면접관은 이거 다 볼 시간이 없다". 이거 였다. 하긴 예전 회사만 해도 팀장님이 이력서 볼 시간도 없이 바쁜데 어찌어찌 사람들은 뽑아오더라. 그러니까 이력서는 그 면접관을 배려해서 작성되어야한다는 것. 

<img src=KakaoTalk_20250501_132032337_01.jpg height = "800" width="600">

처음에는 4장짜리 이력서를 최소화해서 한장 반 분량으로 줄였다. 
### 지원공고 살펴보기 

현재는 5개의 사이트를 돌면서 지원을 하고 있다. 신입 ~ 3년차까지 가리지않고 넣고있다. 기본적으로 지원자수가 200-300명에 달하는 공고가 넘친다. 
1~2년차 경력자 혹은 중고신입에게는 역시 깊이 있는 실무경험을 요구하고 있고, 신입에게는 얼마나 탄탄한 기본기를 가지고 있는지 요구하고 있다. 

- 잡플래닛 
- 원티드 
- 랠릿 
- 점핏 
- 사람인

보통 마스터 이력서를 두고서 회사 전형공고에 따라서 조금씩 수정해서 돌리고 있다. 제발 누가 나좀 뽑아줘.

### 과제전형 탈락,,

그중 전환형 인턴을 뽑는 곳에서 연락을 줘서 과제전형에 응시하게되었다. 최선을 다했지만. 아쉽게 떨어졌다. 다시 멘탈잡고 달려봐야지. 

## 반성해보기 

![[다운로드-_1_.jpg]]

강사님이 수업중에 던져주시는 뼈를 때리는 조언들이 꼭 내 이야기만 같아서 반성하는 시간이 많았다. 실무에서도 물경력 개발자가 많다고. 출퇴근길에 계속 머리에 맴돈다. 1년정도 실무를 경험해봤지만 나는 아직도 기본기가 많이 부족하고. 할 줄 아는것도 많이 없는 개발자라고. 결국은 개발로 1인분을 할려면 공부하는 방법 밖에 없다. 

## 꾸준히 운동하고, 충분히 자고, 공부에만 집중하기 

출퇴근길에는 아이패드를 꾸준히 강의를 듣거나 , 연습문제를 머리속으로 풀었다. 출퇴근길이 왕복 3시간이라 도저히 어떻게 버티지 했는데 . 예습.복습하는 시간으로 사용하니 매우 알찼다.  

퇴근해서는 조금씩이지만 체력을 위해서 꾸준히 운동을 함. 

<div style="display: flex; gap: 10px; justify-content: space-between;">
  <img src="KakaoTalk_20250501_133322797.jpg" width="300">
  <img src="KakaoTalk_20250501_133322797_01.jpg" width="300">
  <img src="KakaoTalk_20250501_133322797_02.jpg" width="300">
  <img src="KakaoTalk_20250501_133322797_03.jpg" width="300">
</div>


## 5주차를 마치며 

이력서를 돌리면서 계속되는 서류 불합격에 많이 지치는 시기였다. 그래도 깃허브 잔디가 쌓이고 내가 부족한 기본기를 쌓아나간다는 점에서 위로가 되었다. 4월달을 보내고, 5월달에도 다시 열심히 이력서를 돌리면서 내 부족한 기본기를 채워넣는 시간으로 만들고 싶다. 

...

추가적으로 JAVA 모듈이 끝나는 기간이였기에. 모듈과제도 회고와 함께 기록한다.
# OOP 과제 진행


![[KakaoTalk_20220415_235350503_24.jpg]]
연습문제 웨이브가 끝나니 나오는 과제라니.. 허허.. 

## 요구사항 분석하기 

요구사항은 한줄로 요약해보자면. 포커 카드게임을 시뮬레이션 돌려서 승자를 가려내는 프로그램을 작성하는 것. 그리고 이를 OOP적인 관점에서 고민해보는 것이다. 

<details>
<summary>과제 요구 사항</summary>
<ul>
  <li>게임 당 한 벌의 카드만 사용. 카드 한 벌은 서로 다른 52장의 카드로 구성.</li>
  <li>카드게임은 최대 4명의 플레이어가 참가 가능</li>
  <li>각 플레이어에게는 게임머니 10000원이 제공된다.</li>
  <li>각 플레이어는 자신만의 고유한 nickname을 가지며 nickname의 길이는 20자를 넘지 못한다.</li>
  <li>딜러는 플레이어에게 서로 <em>다른 5장의 카드</em>를 나눠준다.</li>
  <li>딜러는 플레이어의 카드를 평가하고 결과를 점수로 반환한다.(점수가 높을수록 좋음)</li>
  <li>카드의 평가는 일반적인 포커의 랭크를 참고하여 높은 랭크에게 더 높은 점수를 준다.</li>
  <li>매 게임마다 딜러는 각 플레이어의 카드를 평가하여 결과를 출력한다.</li>
  <li>게임에서 승리한 플레이어는 상금 100원과 1승이 추가되고 나머지 플레이어는 상금 0원과 1패가 추가된다.</li>
  <li>100번의 게임을 자동적으로 반복해서 실행하여 최종 결과를 승리의 수가 많은 플레이어부터 내림차순으로 정렬하여 화면에 출력한다.</li>
</ul>
</details>

## 클래스 설계도 만들기   

### 초기의 설계 

초기에 고민해야할 부분들은 요구사항을 보고서 간단하게 무엇을 클래스(객체)로 지정하고서 정의내릴지였다. 요구사항에서 서로 상호작용하는 대상들은 다음과 같다 .
- 게임 
- 덱 (카드)
- 플레이어
- 딜러 

여기에다가 각각의 게임을 관리해주는 게임매니저라는 개념이 필요해보였다. 해당 요구사항들을 분석했을때 결국 만들어야할건 '포커 게임 시뮬레이터' 였다. 그래서 다음과 같이 조잡하지만 간단하게 클래스 설계도를 잡았다. 

![[Pasted image 20250501154049.png]]

초기 설계에서는 덱이라는 개념을 카드(카드가 모여서 덱이 되니) , 덱 , 카드로 나눠서 표현했다. 이제는 첫번째로 동작할만한 프로그램을 작성해보는 것이 다음 순서였다. 

#### Main 

main은 게임매니저를 실행하고, 결과만을 출력하는등 최대한 간략하게 작성했다. 

```java
public class Main {  
    public static void main(String[] args) {  
        GameManager gameManager = new GameManager();   // 게임 매니저를 생성한다. 
        gameManager.start();   // 게임매니저 시작 
        gameManager.printFinalWinner();  // 게임매니저가 결과를 출력한다. 
    }  
}
```

##### 보완 사항 

해당 부분에서 고려하지 못한 부분은 사용자가 몇번이든지 시뮬레이션을 돌리고 싶을때다. 예를 들어서 100번의 포커카드게임 시뮬레이션을 진행시키고 나서 게임매니저는 다시 사용자에게
 다른 시뮬레이션을 돌리것이냐 VS 이제는 프로그램을 종료할 것이냐 ? 
 를 물어봐야 한다. 해당 로직에서는 설정된 게임시뮬레이션을 한번만 돌릴 수 밖에 없다. 이러면 게임매니저를 설계해서 게임을 관리하게 만든 의미가 퇴색되어 버린다. 우선 기초적인 틀만을 완성하기로 했으니 보완점으로 놔두고서 나머지 로직들을 완성해나가기로 했다. 

#### GameManager 

##### 게임매니저는 플레이어와 게임결과를 관리한다.  딜러는 게임이 관리한다. 

```java
private final List<GameResult> gameResults = new ArrayList<>();  
private final List<Player> players = new ArrayList<>();
```

여기서 딜러라는 개념을 게임매니저가 관리해야하는지에 대해서 많은 고민을 했다. 하지만 게임매니저에는 포함하지 않았다. 다음의 이유들 때문이었다. 

- 플레이어는 게임매니저에 접속되는 존재이다. (실제로도 게임을 한다고 생각했을때 그러하다)
- 하지만 딜러는 플레이어라기 보다는 ( 개념적으로 딜러라는 역할을 맡은 플레이어가 따로 접속하면 모르겠지만) 게임에 종속되어 있는 존재이다. 
- 그리고 플레이어는 이 시뮬레이션 전체과정에서 게임의 바깥에 존재할 수 있지만 (다른 시뮬레이션에 다시 참여할 수 있다.)
- 딜러는 각 게임마다 게임에 따라서 다른 딜러가 배정될 수 있다.
- 즉,  이 모든것들을 고려했을때 게임매니저가 아닌 게임에서 딜러를 관리하는 것이 맞다. 

##### 게임매니저는 게임의 묶음(시뮬레이션)을 실행하고 결과를 기록합니다. 

게임매니저는 2가지 함수로 구성했다. 

start
- start가 호출되면은 게임설정 (시뮬레이션 돌릴 전체 게임 수 , 참여 플레이어 수)를 입력받고서 게임 시뮬레이션을 진행한다. 
- 각 하나하나의 게임의 결과는 따로 리스트를 활용해서 저장해두었다. 
printFinalWinner
- 게임 시뮬레이션이 끝난후에 게임 전체 결과를 출력하는 역할을 한다. 

```java
public void start() {  
    Scanner sc = new Scanner(System.in);  
  
  
    System.out.print("전체 게임수를 입력해주세요: ");  
    this.numOfGmaes = sc.nextInt();  
  
    sc.nextLine(); // 개행 문자 비우기  
  
    System.out.print("참여 플레이어 수를 입력해주세요: ");  
    this.numOfPlayers = sc.nextInt();  
  
    sc.nextLine(); // 개행 문자 비우기  
  
    if (numOfPlayers > MAX_PLAYERS || numOfPlayers < MIN_PLAYERS) {  
        System.out.println("2명 ~ 4명의 플레이어만 참여가능합니다.");  
    }  
  
    // 플레이어 셋팅  
  
    for (int i = 0; i < numOfPlayers; i++) {  
        Player player = new Player(nickNameHelper.generateUniqueNickname(), DEFAULT_MONEY);  
        players.add(player);  
    }  
  
    Dealer dealer = new DealerImpl(nickNameHelper.generateDealerName());  
  
    System.out.println("==== 카드 게임 시뮬레이션 시작 됩니다 ====");  
    System.out.println("숙련된 딜러 - " + dealer + "가 게임을 진행합니다.");  
    System.out.println("플레이어수 : " + numOfPlayers);  
    System.out.println("전체게임수 : " + numOfGmaes);  
  
    for (int i = 0; i < numOfGmaes; i++) {  
        Game game = new Game(players, dealer);  
        GameResult gameResult = game.start();  
        gameResults.add(gameResult);  
    }  
  
  
}
```

##### 어 아까는 딜러는 게임 매니저가 관리 안한다면서 왜 생성해서 게임에 넘겨버림 ? 

게임 매니저는 결국. 플레이들을 생성하고. 딜러를 생성해서 게임에 주입해서 사용하게 된다. 여기서 OOP적인 생성과 책임에 대한 고민이 하나 생겼는데 다음과 같은 고민이었다. 나는 앞서서 딜러라는 
개념은 게임에 종속되어 있지, 게임매니저에 종속되어 있지는 않다라는 결론을 내고서 필드에 딜러라는 필드를 만들지 않았다. 하지만 결국 start라는 함수는 딜러를 생성해서 게임에 넘겨주고 있다. (주입하고 있다) 이를 본다면 딜러라는 개념도 결국 게임매니저가 관리히고 있지 않는가? 이에 대한 gpt의 답은 다음과 같았다. 

##### 너의 고민은 아주 좋다. 헷갈리긴 하지만 결론부터 말하자면 플레이어와 딜러는 역할상 동등하지 않다. 

비록 생성 책임은 GameManager가 둘다 갖지만, 도메인 상 위치와 역할은 확실히 다르다. 

왜냐하면 . 

📌 1. "생성자"와 "도메인 구성원"은 다른 이야기

```java
// GameManager 안
Player player = new Player(...);
Dealer dealer = new DealerImpl(...);
Game game = new Game(players, dealer);

```

이 부분만 보면 분명 "딜러나 플레이어나 둘 다 GameManager에서 만들잖아?"라고 보이지만,  
**"어디서 생성됐냐"는 '의존성 주입 책임'의 문제고**,  
**"어디에 속하느냐"는 '도메인 모델링'의 문제야.**

| 객체       | 역할                   | 소속 도메인               |
| -------- | -------------------- | -------------------- |
| `Player` | 여러 게임에 참여 가능, 독립된 개체 | `GameManager`에 지속 소속 |
| `Dealer` | 특정 게임에서만 일회성 역할 수행   | `Game` 객체 안에서만 활동    |


- **Player는 상태가 지속되며 다수의 게임을 넘나듬**
- **Dealer는 각 게임마다 새로 생성돼 역할을 수행하는 '게임의 부속품'**

즉 핵심적인 차이점은 게임매니저 필드에 Player는 리스트로 선언되어 있어서(도메인에 속해있음), 게임에 넘겨지더라도 상태가 보존되지만 , 
Dealer는 게임이 새로 생성되고 돌아갈때마다 새로 초기화 생성되므로 상태가 보존되지 않는다. 즉 주입만 게임매니저가 하지만 사실상 
"한 게임마다 다른 딜러가 진행된다" 라는 설계원칙은 지켜진것. 그리고 이런 딜러는 값을 보존할 필드변수가 게임매니저에 선언되어 있지 않기에 
특정 게임에서만 일회성 역할을 수행하는 설계원칙에 부합하는것이다. 

그래서 앞의 코드를 다음과 같이 바꿔야 조금 더 설계 원칙에 맞는 것이었다. 

```java
for (int i = 0; i < numOfGmaes; i++) {  
    Dealer dealer = new DealerImpl(nickNameHelper.generateDealerName());  // 매 게임마다 새로운 딜러 생성으로 로직 수정 
    Game game = new Game(players, dealer);  
    GameResult gameResult = game.start();  
    gameResults.add(gameResult);  
}
```

그러면 꼬리에 꼬리를 묻는 질문이지만 다음의 질문이 생긴다. 

그래,, 새로운 딜러가 각각의 새로운 게임에 참여하게 된다라는 개념은 설계개념에 맞긴하지만 ,
##### 이러면 한게임을 진행할때마다 딜러가 새로 생성되는 로직이 한번씩 더 도는건데 낭비 아니냐? 

일단 답변부터 내놓자면 , 

딜러를 매 게임마다 새로 생성하는 건 **약간의 비용은 있지만**,  
**설계적 유연성과 확장성 측면에서 충분히 정당한 trade-off**야.  
특히 시뮬레이션처럼 다양한 조건을 실험하는 구조에서는 **필수에 가까움**.

🔍 왜 정당한가? — 개념 정리

|항목|플레이어|딜러|
|---|---|---|
|수명주기|세션 전체에 지속|**게임 단위로 생성/소멸**|
|상태 지속성|있음 (돈, 승/패 등)|거의 없음 (룰 기반의 판정기 역할)|
|역할|외부 액터|룰 실행 엔진 or 심판|
##### 🧠 지금은 "낭비 같지만" 미래엔?

"딜러는 로직도 별거 없고, 그냥 한 명으로도 충분한데 왜 매번 만들지?"
근데 나중에 이런 요구사항 들어오면?

💥 딜러 확장 예시들

- **딜러마다 스타일이 다르다** (랜덤성, 부정행위 감지, AI 딜러)
- **딜러마다 사용하는 룰셋이 다르다** (예: 텍사스 홀덤 vs 오마하)
- **딜러마다 통계 정보를 수집한다**
- **테스트용 딜러**, 결과 고정하는 딜러 (정확한 테스트를 위해)

→ 이때 `DealerFactory`나 전략 패턴 도입해서 매 게임마다 다른 딜러 주입하면  
**테스트, 분석, 기능별 스위칭** 전부 자유로워짐.

```java
for (int i = 0; i < numOfGames; i++) {
    Dealer dealer = dealerFactory.createRandomDealer(); // 다양성 도입 가능
    Game game = new Game(players, dealer);
    ...
}
```

##### +) 딜러하고 플레이어 이름을 랜덤으로 설정해보기 

여기서 재미있는 요소를 하나 넣고 싶었다. 게임매니저는 딜러와 플레이어를 세팅해서 시뮬레이션을 돌리니 . 플레이어와 딜러를 선택할 때 플레이어의 닉네임은 유니크하게 , 딜러의 이름은 카지노 내에 있는 딜러들중 랜덤으로 게임에 참여한다는 개념으로 만들어서 다음과 같이 랜덤으로 플레이어의 닉네임을 생성하고, 딜러의 이름을 반환하는 Helper 클래스를 하나 따로 만들었다. 

```java
public class NickNameHelper {  
    private static final String[] dealerNames = {  
            "Jack Carter",  
            "Sam Wilson",  
            "Mike Johnson",  
            "Emily Davis",  
            "Chris Taylor",  
            "Olivia Brown",  
            "James Miller",  
            "Sophia Anderson",  
            "Ethan Harris",  
            "Ava Martin"  
    };  
    private static final String[] adjectives = {  
            "Lucky", "Fearless", "Sharp", "Cold", "Bold", "Silent", "Cunning", "Mighty"  
    };  
  
    private static final String[] nouns = {  
            "Ace", "King", "Queen", "Jack", "Card", "Dealer", "Gambler", "Shark"  
    };  
  
    Random random = new Random();  
    private final Set<String> nicknameSet = new HashSet<>();  
  
    // 플레이어 닉네임 생성 함수  
    public String generateUniqueNickname() {  
  
  
        while (true) {  
            String adjective = adjectives[random.nextInt(adjectives.length)];  
            String noun = nouns[random.nextInt(nouns.length)];  
            int number = random.nextInt(1000, 9999); // 1000~9999  
  
            String nickname = adjective + noun + number;  
  
            if (!nicknameSet.contains(nickname)) {  
                nicknameSet.add(nickname);  
                return nickname;  
            }  
        }  
    }  
  
    public String generateDealerName() {  
        Random random = new Random();  
  
        return dealerNames[random.nextInt(dealerNames.length)];  
    }  
}
```

+) 보완점 

이러면 나중에 멀티쓰레드 구조로 여러개의 게임이 비동기적으로 진행된다고 가정했을때 같은 이름을 가진 동일 딜러가 같은 시간대에 다른 게임에 참여하는 문제가 발생한다. 해당 부분은 인지만 해두고 나중에 보완해두자. 

자 이제 게임을 시뮬레이션하는 로직은 완성했다. 이제는 각 시뮬레이션의 최소 단위가 되는 게임이라는 클래스에 대해서 설계해보자. 
#### 
### 족보 판단 로직 

## 중반부의 설계 변경 

### DI 컨테이너의 도입 

#### 여기서 정리하고 가는 OOP의 설계 원칙들 
### 테스트코드 작성하기 

## 과제 업그레이드 해보기

### 멀티쓰레드 한번 도입해보기 

### DB에 값 저장해보기 

#### ERD 설계

## 스프링 부트 프로젝트로의 포팅 

### 계층의 분리와 고민 
### 사용자를 추가해보자 - 로그인 로직 

### 로직들의 변경 

#### 람다와 스트림을 극한까지 사용해보자. 